{
    "contents" : "# cross validation in original dataset\n# cv_original take the dataset and generate the beta estimation\n# use nlm() to get the estimation of lambda\n# input: dataset(original(after deleting missing value), logistics), k(>=2),nonzero num of parameter\n#        list of intial lambda(lam_ini_lasso,lam_ini_SCAD,lam_ini_MCP,defaul is -99 which means we get lambda path from the package)\n# output: best lambda by cross validation with three values(lasso, SCAD, MCP)ï¼Œbeta_est, method used to choose initial lambda for nlm(),\n#         time used to get the estimation\n\n#check package\nif(!require(\"glmnet\")){\n  install.packages(\"glmnet\")\n  library(glmnet)\n}\nif(!require(\"ncvreg\")){\n  install.packages(\"ncvreg\")\n  library(ncvreg)\n}\n\n########################################################\n#' define a function to estimte the lambda(our method) based on nlm() or nlminb()\n#' input: data_original(after deleting missing), data_logistics, k(number of folder),\n#'        lam_indicator, penalty_indicator, method_indicator(nlm() or nlminb())\n#' output: list - estimation of lambda\nlambda_estimator <- function(sample_original=sample_original,sample_logistic=sample_logistic,k=k,\n                             lam_indicator=-99,\n                             penalty_indicator=penalty_indicator,\n                             minimal_method){\n  #' lminimal_method = nlm\n  #'               = nlminb\n  \n  lambda_est <- -999\n  \n  #begin count time\n  run_time <- proc.time()\n  \n  \n  #get initial value\n  lambda_ini <- initial_universial_calculator(sample_original=sample_original,sample_logistic=sample_logistic,k=k,\n                                lam_indicator=lam_indicator,\n                                penalty_indicator=penalty_indicator)$initial_lambda_value\n  if (minimal_method==\"nlm\"){\n    \n  }else if(minimal_method==\"nlminb\"){\n    \n  }else stop(\"lambda_method input is wrong lambda_estimator\")\n  \n  #end count time \n  run_time <- proc.time() - run_time\n  \n  #check the estimation\n  if (lambda_est == -999) stop(\"lambda estimation is wrong lambda_estimator\")\n  \n  result <- list(lambda_estimation = lambda,estimation_time_using = run_time,\n                 method_used = minimal_method,lambda_initial=lambda_ini)\n  \n}\n\n\n\n########################################################\n# define a universial initial calculator\n# function to find initial value of lambda for nlm()\n# input: data_original(after deleting missing), data_logistics, k(number of folder), lam_indicator, penalty_indicator\n# ouput: a list-initial value, corresponding cv value, time used, method used and numeric indicator\n#        lambda_path, corresponding cv_path, penalty type\n\ninitial_universial_calculator <- function(sample_original=sample_original,sample_logistic=sample_logistic,k=k,\n                                          lam_indicator=-99,\n                                          penalty_indicator=penalty_indicator){\n  #' to calculate initial value for lasso, SCAD, MCP based on the penalty_indicator\n  #' two step:\n  #' first, use package or user input to get a path of lambda, it can be a single value or vector\n  #' second, if the path of lambda is a vecotr, choose the lambda give the minimum cv value(from our method) from the vector\n  #'         if the path of lambda is a scalar, just return it\n  #' output: list - inital value, initial cv value, time cost, lambda path, cv(our method) path, method used(text, inidcator), penalty type \n  \n  # lam_indicator : define how to choose initial value of lambda\n  #               = -99: the initial value is the lambda give the minimum cv value(from our method) from the path of lambda got from the package\n  #               = -98: use the lambda got from cross validation provided by the package\n  #               = vector: find a lambda which is from this vector gives the minimum cv value(from our method)\n  #               = scalar: use this value as the initial value\n  \n  #' text message for initial method\n  #' ini_method_ind: 1: lambda path from package\n  #'                 2: lambda from package cross validation\n  #'                 3: user input vector\n  #'                 4: user input scalar\n  #'                -1: something wrong\n  \n  # check k is in the correct range\n  if(k<2 | k>dim(sample_original)[1]) stop(\"k should be greater than 1 and less than the rows in the original data(after deleting missing)\")\n  \n  # generate logistic list\n  logistic_list <- cv_logistic_prepare(sample_original=sample_original,k=k)\n  \n  ini_method <- \"ini_method\"\n  ini_method_ind <- -1\n  \n  initial_value <- -999\n  \n  #begin count time\n  run_time <- proc.time()\n  \n  #first, generate lambda path\n  if (length(lam_indicator) > 1){\n    ini_method <- \"user input vector\"\n    ini_method_ind <- 3\n    lam_path <- lam_indicator\n  }else{if (lam_indicator == -99){\n    ini_method <- \"lambda path from package\"\n    ini_method_ind <- 1\n    if (penalty_indicator == \"lasso\"){\n      lam_path <- glmnet(as.matrix(sample_logistics[,-1]),factor(sample_logistics[,1],levels=c(0,1)),family=\"binomial\")$lambda\n    } else if (penalty_indicator == \"SCAD\"){\n      lam_path <- ncvreg(as.matrix(sample_logistics[,-1]),sample_logistics[,1],family=\"binomial\",penalty=\"SCAD\")$lambda\n    } else if (penalty_indicator == \"MCP\"){\n      lam_path <- ncvreg(as.matrix(sample_logistics[,-1]),sample_logistics[,1],family=\"binomial\",penalty=\"MCP\")$lambda\n    } else stop(\" penalty_indicator is wrong\")\n  }else if (lam_indicator == -98){\n    ini_method <- \"lambda from package cross validation\"\n    ini_method_ind <- 2\n    if (penalty_indicator == \"lasso\"){\n      lam_path <- cv.glmnet(as.matrix(logistic_sample[,-1]),factor(logistic_sample[,1],levels=c(0,1)),family=\"binomial\",type.measure = \"class\")$lambda.min\n    } else if (penalty_indicator == \"SCAD\"){\n      lam_path <- cv.ncvreg(as.matrix(logistic_sample[,-1]),logistic_sample[,1],family=\"binomial\",penalty=\"SCAD\")$lambda.min\n    } else if (penalty_indicator == \"MCP\"){\n      lam_path <- cv.ncvreg(as.matrix(logistic_sample[,-1]),logistic_sample[,1],family=\"binomial\",penalty=\"MCP\")$lambda.min\n    } else stop(\" penalty_indicator is wrong initial_universial_calculator\")\n  }else if (length(lam_indicator) == 1){\n    ini_method <- \"user input scalar\"\n    ini_method_ind <- 4\n    lam_path <- lam_indicator\n  }else stop(\"lam_indicator input wrong initial_universial_calculator\")\n  }\n  \n  #second, choose initial lambda\n  #genereate corresponding cv from our method\n  #define a function to generate cv from our method cv_calculator\n  if(length(lam_path)>=1){\n    #create a matrix to store lambda value and corresponding cv value(our method)\n    path_matrix <- matrix(-99,length(lam_path),2)\n    colnames(path_matrix) <- c(paste(\"lambda_\",penalty_indicator,sep = \"\"),\"cv_value\")\n    for (i in 1:length(lam_path)){\n      path_matrix[i,1] <- lam_path[i]\n      path_matrix[i,2] <- cv_calculator(lambda=lam_path[i],sample_original=sample_original,logistic_list=logistic_list,k=k,penalty_indicator=penalty_indicator)\n      initial_value <- path_matrix[,1][which.min(path_matrix[,2])]\n      min_cv_value <- min(path_matrix[,2])\n      print(paste(penalty_indicator,\"_\",i,sep = ))\n    }\n  }else stop(\"lambda path is wrong initial_universial_calculator\")\n  \n  #end count time \n  run_time <- proc.time() - run_time\n  \n  #check initial value\n  if (initial_value == -999) stop(\"initial calculation wrong initial_universial_calculator\")\n  result <- list(initial_lambda_value=initial_value,cv_value=min_cv_value,time_cost_initial=run_time,\n                 method=ini_method,method_ind=ini_method_ind,\n                 lambda_path=lam_path,lambda_path_cv=path_matrix[,2],\n                 penalty=penalty_indicator)\n  return(result)\n}\n\n########################################################\n#function to calculate the log-pseudolikelihood\n#input:dataset,beta_estimation\n#output: likelihood value\nloglikelihood <- function(dataset,beta_estimation){\n  obs_length <- dim(dataset)[1]\n  dataset_y <- dataset[,1]\n  dataset_x <- cbind(1,dataset[,-1])\n  #   print(head(dataset_y))\n  #   print(head(dataset_x))\n  #   beta_estimation <- beta_est\n  #   dataset <- sample_original\n  #   i <- 5\n  #   j <- 10\n  \n  count <- 0\n  loglikelihood <- 0\n  for (j in 1:obs_length){\n    for(i in 1:obs_length){\n      if (i<j){\n        loglikelihood <- loglikelihood + (-log(1+exp(-(dataset_y[i]-dataset_y[j])*sum(beta_estimation*(dataset_x[i,]-dataset_x[j,])))))\n        count <- count +1\n      }\n    }\n  }\n  #print(count)\n  loglikelihood <- loglikelihood/count\n  return(loglikelihood)\n}\n\n########################################################\n#function used to get beta estimation\n#input: logistics dataset, singe lambda value, penalty indicator(lasso, SCAD, MCP)\n#output: estimaiton of beta\nbeta_est <- function(data_logistics,lambda,penalty_indicator){\n  if (penalty_indicator == \"lasso\"){\n    fit_lasso<- glmnet(as.matrix(data_logistics[,-1]),factor(data_logistics[,1],levels=c(0,1)),family=\"binomial\",lambda = lambda)\n    coef1 <- coef(fit_lasso,s = lambda)\n    beta_est <- rep(0,coef1@Dim[1])\n    x_ind <- 0\n    for (i in coef1@i){\n      x_ind <- x_ind +1\n      beta_est[i+1] <- coef1@x[x_ind]\n    }\n    beta_row_name <- c(\"(Intercept)\")\n    for (i in 1:(length(beta_est)-1)){\n      beta_row_name <- c(beta_row_name,paste(\"x\",i,sep = \"\"))\n    }\n    beta_est <- matrix(beta_est,length(beta_est),1)\n    rownames(beta_est) <- beta_row_name\n    colnames(beta_est) <- lambda\n    return(beta_est)\n  }else if(penalty_indicator == \"SCAD\"){\n    fit_SCAD <- ncvreg(as.matrix(data_logistics[,-1]),data_logistics[,1],family=\"binomial\",penalty=\"SCAD\",lambda = lambda)\n    beta_est <- fit_SCAD$beta\n    return(beta_est)\n  }else if(penalty_indicator == \"MCP\"){\n    fit_MCP <- ncvreg(as.matrix(data_logistics[,-1]),data_logistics[,1],family=\"binomial\",penalty=\"MCP\",lambda = lambda)\n    beta_est <- fit_MCP$beta\n    return(beta_est)\n  }else stop(\" penalty_indicator is wrong beta_est\")\n}\n\n############################################\n#logistics data generator: get the logistics dataset from original dataset\n#input:original dataset\n#output:logistics dataset\nlogistic_generator <- function(data1){\n  #covert to logistic regression data\n  logistic_sample <- matrix(0, choose(dim(data1)[1],2), dim(data1)[2])\n  n_sample1 <- dim(data1)[1]\n  row_count <- 1\n  for(j in 1:n_sample1){\n    for(i in 1:n_sample1){\n      if (i<j){\n        sgn1 <- -(data1[i,1]-data1[j,1])\n        xval <- as.matrix((data1[i,-1]-data1[j,-1])*abs(data1[i,1]-data1[j,1]))\n        if (sgn1>0){\n          obs_temp <- c(0,xval)\n          logistic_sample[row_count,] <- obs_temp\n        }else if(sgn1<0){\n          obs_temp <- c(1,xval)\n          logistic_sample[row_count,] <- obs_temp\n        }else if(sgn1 == 0){\n          # delete after dataset generated\n          obs_temp <- c(-1,xval)\n          logistic_sample[row_count,] <- obs_temp\n        }\n        row_count = row_count + 1\n      }\n    }\n  }\n  \n  logistic_sample <- as.data.frame(logistic_sample)\n  colnames(logistic_sample) <- colnames(data1)\n  # delete sgn = 0\n  logistic_sample <- subset(logistic_sample,y!=-1)\n  #head(logistic_sample)\n  #tail(logistic_sample)\n  return(logistic_sample)\n}\n\n############################################\n#cv_logistic_prepare: generate the logistic dataset in a list for cv\n#the purpose of this function is save time by avoiding generate logistic list every time\n#input: sample_original,k\n#output: a list with all logistic dataset for cross valiadation(our method)\n\ncv_logistic_prepare <- function(sample_original=sample_original,k=k){\n  #generate a list to store the obs number be removed in cross validation\n  dim_module <- dim(sample_original)[1] %% k\n  obs_length <-dim(sample_original)[1] %/% k\n  obs_list <- list() \n  for(i in 1:k){\n    if (i <= dim_module) obs_list[[i]] <- ((i-1)*obs_length + (i-1)+1):(i*obs_length + i)\n    else obs_list[[i]] <- (obs_length * dim_module + dim_module + obs_length*(i-dim_module-1)+1):\n        (obs_length * dim_module + dim_module + obs_length*(i-dim_module))\n  }\n  \n  #generate the logistic dataset in a list\n  logistic_list <- list()\n  for (i in 1:k){\n    data_k <- sample_original[-obs_list[[i]],]\n    logistic_list[[i]] <- logistic_generator(data_k)\n  }\n  return(logistic_list)\n}\n#get the logistic list data\n#logistic_list <- cv_logistic_prepare(sample_original=sample_original,k=k)\n\n\n############################################\n#cv_calculator: calculate cv values(our method) based on the input lambda(scalar)\n#input: lambda, sample_original, k, penalty_indicator\n#ouput: a single cv_value corresponding to lambda and penalty_indicator\ncv_calculator <- function(lambda,sample_original=sample_original,logistic_list=logistic_list,k=k,penalty_indicator=penalty_indicator){\n  #generate a list to store the obs number be removed in cross validation\n  dim_module <- dim(sample_original)[1] %% k\n  obs_length <-dim(sample_original)[1] %/% k\n  obs_list <- list() \n  for(i in 1:k){\n    if (i <= dim_module) obs_list[[i]] <- ((i-1)*obs_length + (i-1)+1):(i*obs_length + i)\n    else obs_list[[i]] <- (obs_length * dim_module + dim_module + obs_length*(i-dim_module-1)+1):\n        (obs_length * dim_module + dim_module + obs_length*(i-dim_module))\n  }\n  if(length(logistic_list) != k) stop(\"logistics list does not match k cv_calculator\")\n  \n  #calculate the cv value\n  if (penalty_indicator %in% c(\"lasso\",\"SCAD\",\"MCP\")){\n    #lasso\n    result <- matrix(0,1,2)\n    colnames(result) <- c(paste(\"lambda_\",penalty_indicator,sep = \"\"),\"cv_value\")\n    cv_vec <- rep(0,k)\n    lambda <- lambda\n    for (j in 1:k){\n      beta_est_k <- beta_est(data_logistics=logistic_list[[j]],lambda=lambda,penalty_indicator=penalty_indicator)\n      print(beta_est_k)\n      ll <- loglikelihood(sample_original,beta_est_k)\n      ll_k <- loglikelihood(sample_original[-obs_list[[j]],],beta_est_k)\n      cv_vec[j] <- (ll-ll_k)^2\n      print(cv_vec)\n    }\n    result[1,1] <- lambda\n    result[1,2] <- sum(cv_vec)\n  }else stop(\"penalty_indicator is wrong cv_calculator\")\n  return(result[1,2])\n}\n\n\n\n\n\n\n\n",
    "created" : 1444448152647.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "708256953",
    "id" : "FA32D670",
    "lastKnownWriteTime" : 1444448271,
    "path" : "~/Dropbox/YangYang/01.pseudo_likelihood_logistic_regression/wrong_cv_vector/07.cv_esimator.R",
    "project_path" : "07.cv_esimator.R",
    "properties" : {
    },
    "relative_order" : 1,
    "source_on_save" : false,
    "type" : "r_source"
}